var searchIndex={};
searchIndex["kernel"] = {"doc":"","i":[[5,"eh_personality","kernel","",null,[[]]],[5,"panic","","Panic handler",null,[[["panicinfo"]]]],[5,"abort","","Abort function",null,[[]]],[0,"arch","","RISC-V related functions",null,null],[5,"time","kernel::arch","Get current time from MMIO",null,[[],["duration"]]],[5,"build_satp","","Build satp value from mode, asid and page table base addr",null,[[["usize"]],["usize"]]],[5,"intr_on","","Enable interrupt",null,[[]]],[5,"intr_off","","Turn off interrupt",null,[[]]],[5,"intr_get","","Check if interrupt is enabled",null,[[],["bool"]]],[5,"hart_id","","",null,[[],["usize"]]],[5,"r_sip","","",null,[[],["usize"]]],[5,"w_sip","","",null,[[["usize"]]]],[5,"r_sstatus","","",null,[[],["usize"]]],[5,"r_satp","","",null,[[],["usize"]]],[5,"w_sstatus","","",null,[[["usize"]]]],[5,"__sync_synchronize","","",null,[[]]],[5,"__sync_lock_test_and_set","","",null,[[["u32"],["u32"]],["u32"]]],[5,"__sync_lock_release","","",null,[[["u32"]]]],[5,"w_ra","","",null,[[["usize"]]]],[5,"sp","","",null,[[],["usize"]]],[5,"wait_forever","","",null,[[]]],[0,"elf","kernel","ELF parsing",null,null],[3,"ELFHeader","kernel::elf","",null,null],[12,"magic","","",0,null],[12,"elf","","",0,null],[12,"etype","","",0,null],[12,"machine","","",0,null],[12,"version","","",0,null],[12,"entry","","",0,null],[12,"phoff","","",0,null],[12,"shoff","","",0,null],[12,"flags","","",0,null],[12,"ehsize","","",0,null],[12,"phentsize","","",0,null],[12,"phnum","","",0,null],[12,"shentsize","","",0,null],[12,"shnum","","",0,null],[12,"shstrndx","","",0,null],[3,"ProgramHeader","","",null,null],[12,"ptype","","",1,null],[12,"flags","","",1,null],[12,"off","","",1,null],[12,"vaddr","","",1,null],[12,"paddr","","",1,null],[12,"filesz","","",1,null],[12,"memsz","","",1,null],[12,"align","","",1,null],[5,"parse_elf","","",null,[[["table"]],["u64"]]],[5,"load_segment","","",null,[[["usize"],["table"]]]],[17,"ELF_PROG_LOAD","","",null,null],[17,"ELF_PROG_FLAG_EXEC","","",null,null],[17,"ELF_PROG_FLAG_WRITE","","",null,null],[17,"ELF_PROG_FLAG_READ","","",null,null],[17,"ELF_MAGIC","","",null,null],[0,"mem","kernel","Allocator implementation",null,null],[3,"Allocator","kernel::mem","Frame allocator gives out one or more pages.",null,null],[12,"page_allocated","","A bool array records whether a page is handed out",2,null],[12,"base_addr","","Pages are handed out from `base_addr`, which is the start…",2,null],[3,"OsAllocator","","",null,null],[5,"align_val","","Align an address to upper bound according to specified…",null,[[["usize"]],["usize"]]],[5,"align_val_down","","Align an address to lower bound according to specified…",null,[[["usize"]],["usize"]]],[5,"page_down","","Align an address to the begin of a page.",null,[[["usize"]],["usize"]]],[5,"init","","Initialize allocator and kernel page table This function…",null,[[]]],[5,"hartinit","","",null,[[]]],[5,"ALLOC","","",null,[[],["mutex"]]],[5,"alloc_error","","",null,[[["layout"]]]],[5,"zero_volatile","","",null,[[["range"]]]],[5,"debug","","",null,[[]]],[5,"alloc_stack","","",null,[[]]],[7,"__ALLOC","","",null,null],[7,"GA","","",null,null],[17,"MAX_PAGE","","Maximum number of pages. As QEMU and linker script…",null,null],[11,"new","","Returns a new allocator instance",2,[[],["self"]]],[11,"offset_addr_of","","",2,[[["self"],["usize"]],["usize"]]],[11,"offset_id_of","","",2,[[["self"],["usize"]]]],[11,"offset_page_of","","",2,[[["self"]],["usize"]]],[11,"allocate","","",2,[[["self"],["usize"]]]],[11,"deallocate","","",2,[[["self"]]]],[11,"debug","","Print page allocation status",2,[[["self"]]]],[0,"spinlock","kernel","A RISC-V Mutex",null,null],[3,"Mutex","kernel::spinlock","A RISC-V Mutex.",null,null],[12,"lock","","Indicate whether data is locked. Will be passed into C code.",3,null],[12,"name","","Lock name, for debug use",3,null],[12,"hart","","HartID holding the lock",3,null],[12,"data","","Save actual data",3,null],[3,"MutexGuard","","A guard to which the protected data can be accessed",null,null],[12,"lock","","",4,null],[12,"mutex","","",4,null],[12,"data","","",4,null],[12,"intr_lock","","",4,null],[3,"WeakMutexGuard","","",null,null],[12,"mutex","","",5,null],[11,"new","","",3,[[["str"],["t"]],["mutex"]]],[11,"into_inner","","Consumes this mutex, returning the underlying data.",3,[[],["t"]]],[11,"obtain_lock","","Obtain lock by test_and_set",3,[[["self"]]]],[11,"lock","","Lock mutex and return a guard",3,[[["self"]],["mutexguard"]]],[11,"holding","","Test if lock is held by current hart",3,[[["self"]],["bool"]]],[11,"get","","Directly get mutex data regardless whether it is locked or…",3,[[["self"]],["t"]]],[11,"into_weak","","Temporarily unlock Mutex by obtaining a weak guard",4,[[],["weakmutexguard"]]],[11,"into_guard","","Temporarily unlock Mutex by obtaining a weak guard",5,[[],["mutexguard"]]],[0,"page","kernel","Paging implementaion and page table abstraction",null,null],[3,"Table","kernel::page","",null,null],[12,"entries","","",6,null],[3,"Page","","",null,null],[12,"data","","",7,null],[3,"Entry","","",null,null],[12,"0","","",8,null],[3,"VPN","","",null,null],[12,"0","","",9,null],[3,"PPN","","",null,null],[12,"0","","",10,null],[4,"EntryAttributes","","",null,null],[13,"D","","",11,null],[13,"A","","",11,null],[13,"G","","",11,null],[13,"U","","",11,null],[13,"X","","",11,null],[13,"W","","",11,null],[13,"R","","",11,null],[13,"V","","",11,null],[13,"RW","","",11,null],[13,"RX","","",11,null],[13,"UR","","",11,null],[13,"URW","","",11,null],[13,"URX","","",11,null],[7,"KERNEL_PGTABLE","","Kernel page table",null,null],[17,"TABLE_ENTRY_CNT","","",null,null],[11,"new","","",7,[[],["box"]]],[11,"is_d","","",8,[[["self"]],["bool"]]],[11,"is_a","","",8,[[["self"]],["bool"]]],[11,"is_g","","",8,[[["self"]],["bool"]]],[11,"is_u","","",8,[[["self"]],["bool"]]],[11,"is_x","","",8,[[["self"]],["bool"]]],[11,"is_w","","",8,[[["self"]],["bool"]]],[11,"is_r","","",8,[[["self"]],["bool"]]],[11,"is_v","","",8,[[["self"]],["bool"]]],[11,"is_leaf","","",8,[[["self"]],["bool"]]],[11,"paddr","","",8,[[["self"]],["ppn"]]],[11,"flags","","",8,[[["self"]],["usize"]]],[11,"new","","",8,[[["usize"]],["self"]]],[11,"ppn0","","",10,[[["self"]],["usize"]]],[11,"ppn1","","",10,[[["self"]],["usize"]]],[11,"ppn2","","",10,[[["self"]],["usize"]]],[11,"idx","","",10,[[["self"],["usize"]],["usize"]]],[11,"clone_page","","",10,[[["self"]],[["page"],["box",["page"]]]]],[11,"vpn0","","",9,[[["self"]],["usize"]]],[11,"vpn1","","",9,[[["self"]],["usize"]]],[11,"vpn2","","",9,[[["self"]],["usize"]]],[11,"idx","","",9,[[["self"],["usize"]],["usize"]]],[11,"new","","",6,[[],["self"]]],[11,"len","","",6,[[["self"]],["usize"]]],[11,"map","","",6,[[["box",["page"]],["usize"],["page"],["self"]]]],[11,"kernel_map","","",6,[[["self"],["usize"]]]],[11,"map_addr","","",6,[[["self"],["usize"]]]],[11,"paddr_of","","",6,[[["self"],["usize"]],[["option",["usize"]],["usize"]]]],[11,"_walk","","",6,[[["self"],["usize"]]]],[11,"walk","","",6,[[["self"]]]],[11,"id_map_range","","",6,[[["self"],["usize"]]]],[11,"map_range","","",6,[[["self"],["usize"]]]],[11,"drop_walk","","",6,[[["self"],["usize"]]]],[11,"clone_walk","","",6,[[["self"],["usize"]],["box"]]],[11,"unmap_user","","",6,[[["self"]]]],[0,"print","kernel","Macros for output",null,null],[7,"INFO_LOCK","kernel::print","",null,null],[0,"process","kernel","Process and scheduling",null,null],[4,"ProcInPool","kernel::process","Enum describing a process in process pool",null,null],[13,"NoProc","","",12,null],[13,"Scheduled","","",12,null],[13,"Pooling","","",12,null],[13,"BeingSlept","","",12,null],[5,"init","","",null,[[]]],[5,"my_cpu","","Get CPU object of current hart.",null,[[],["cpu"]]],[5,"my_proc","","Get reference to current running process on current hart.",null,[[],["process"]]],[5,"debug","","",null,[[]]],[0,"trapframe","","",null,null],[3,"TrapFrame","kernel::process::trapframe","Trap frame contains information for switching to and…",null,null],[12,"regs","","integer registers",13,null],[12,"fregs","","floating point registers",13,null],[12,"satp","","kernel satp register",13,null],[12,"sp","","kernel sp",13,null],[12,"hartid","","kernel hartid",13,null],[12,"trap","","`usertrap` function address",13,null],[12,"epc","","sret target address",13,null],[4,"Register","","Mapping between register name and trapframe `regs` array…",null,null],[13,"zero","","",14,null],[13,"ra","","",14,null],[13,"sp","","",14,null],[13,"gp","","",14,null],[13,"tp","","",14,null],[13,"t0","","",14,null],[13,"t1","","",14,null],[13,"t2","","",14,null],[13,"s0","","",14,null],[13,"s1","","",14,null],[13,"a0","","",14,null],[13,"a1","","",14,null],[13,"a2","","",14,null],[13,"a3","","",14,null],[13,"a4","","",14,null],[13,"a5","","",14,null],[13,"a6","","",14,null],[13,"a7","","",14,null],[11,"zero","","create an initialized trapframe",13,[[],["self"]]],[0,"cpu","kernel::process","",null,null],[3,"CPU","kernel::process::cpu","Holding CPU information",null,null],[12,"scheduler_context","","",15,null],[12,"process","","",15,null],[12,"intr_lock","","",15,null],[3,"IntrLock","","Control interrupt",null,null],[12,"is_enabled_before","","",16,null],[12,"cnt","","",16,null],[12,"hart_id","","",16,null],[3,"IntrLockGuard","","IntrLock Guard",null,null],[12,"lock","","",17,null],[11,"zero","","",15,[[],["self"]]],[11,"new","","",16,[[],["self"]]],[11,"lock","","",16,[[["self"]],["intrlockguard"]]],[0,"process","kernel::process","",null,null],[3,"Process","kernel::process::process","",null,null],[12,"pgtable","","",18,null],[12,"trapframe","","",18,null],[12,"context","","",18,null],[12,"state","","",18,null],[12,"kstack","","",18,null],[12,"kstack_sp","","",18,null],[12,"pid","","",18,null],[12,"channel","","",18,null],[12,"drop_on_put_back","","",18,null],[12,"files","","",18,null],[4,"ProcessState","","",null,null],[13,"UNUSED","","",19,null],[13,"SLEEPING","","",19,null],[13,"RUNNABLE","","",19,null],[13,"RUNNING","","",19,null],[13,"ZOMBIE","","",19,null],[5,"forkret","","",null,[[]]],[5,"init_code","","binary code of user/src/initcode.S This file will be…",null,[[]]],[5,"init_proc","","Put init process into `PROCS_POOL`",null,[[]]],[5,"find_available_pid","","",null,[[],[["option",["i32"]],["i32"]]]],[5,"fork","","",null,[[],["i32"]]],[5,"map_stack","","map user stack in `pgtable` at `stack_begin` and returns…",null,[[["table"],["usize"]],["usize"]]],[5,"exec","","exec syscall",null,[[["str"]]]],[5,"exit","","exit syscall",null,[[["i32"]]]],[5,"sleep","","put this process into sleep state",null,[[["mutexguard"]],["mutexguard"]]],[5,"wakeup","","wakeup process on channel",null,[[]]],[7,"PROCS_POOL_SLEEP","","A Mutex that will be locked if a process is being slept…",null,null],[17,"USER_STACK_PAGE","","",null,null],[11,"new","","",18,[[["i32"]],["self"]]],[11,"from_exist","","",18,[[["table"],["trapframe"],["box",["table"]],["i32"],["box",["trapframe"]]],["self"]]],[0,"context","kernel::process","",null,null],[3,"Context","kernel::process::context","Kernel context",null,null],[12,"regs","","",20,null],[4,"ContextRegisters","","",null,null],[13,"ra","","",21,null],[13,"sp","","",21,null],[5,"swtch","","switch context",null,[[["context"],["context"]]]],[5,"sched","","switch to scheduler context",null,[[]]],[5,"yield_cpu","","give up CPU to scheduler",null,[[]]],[5,"__swtch","","__swtch in `swtch.S`",null,null],[11,"zero","","",20,[[],["self"]]],[0,"schedule","kernel::process","",null,null],[5,"find_next_runnable_proc","kernel::process::schedule","Find a runnable process whose pid >= `from_pid`",null,[[["usize"]],[["box",["process"]],["option",["box"]]]]],[5,"put_back_proc","","Put process back to `PROCS_POOL`",null,[[["box",["process"]],["process"]]]],[5,"scheduler","","Kernel scheduler",null,[[]]],[7,"CPUS","kernel::process","An array holding all CPU information",null,null],[7,"PROCS_POOL","","An array holding all process information.",null,null],[0,"symbols","kernel","Linker-script constants and RISC-V constants (This module…",null,null],[5,"bss_range","kernel::symbols","",null,[[],["range"]]],[5,"print_map_symbols","","",null,[[]]],[5,"uservec","","`uservec` function in `trampoline.S`",null,null],[5,"userret","","`userret` function in `trampoline.S`",null,null],[5,"kernelvec","","`kernelvec` function in `kernelvec.S`",null,null],[5,"timervec","","`m_trap_vector` function in `trap.S`",null,null],[0,"gen","","This module is automatically generated with…",null,null],[5,"HEAP_START","kernel::symbols::gen","",null,[[],["usize"]]],[5,"HEAP_SIZE","","",null,[[],["usize"]]],[5,"TEXT_START","","",null,[[],["usize"]]],[5,"TEXT_END","","",null,[[],["usize"]]],[5,"RODATA_START","","",null,[[],["usize"]]],[5,"RODATA_END","","",null,[[],["usize"]]],[5,"DATA_START","","",null,[[],["usize"]]],[5,"DATA_END","","",null,[[],["usize"]]],[5,"BSS_START","","",null,[[],["usize"]]],[5,"BSS_END","","",null,[[],["usize"]]],[5,"KERNEL_STACK_START","","",null,[[],["usize"]]],[5,"KERNEL_STACK_END","","",null,[[],["usize"]]],[5,"TRAMPOLINE_TEXT_START","","",null,[[],["usize"]]],[7,"__heap_start","","",null,null],[7,"__heap_size","","",null,null],[7,"__text_start","","",null,null],[7,"__text_end","","",null,null],[7,"__rodata_start","","",null,null],[7,"__rodata_end","","",null,null],[7,"__data_start","","",null,null],[7,"__data_end","","",null,null],[7,"__bss_start","","",null,null],[7,"__bss_end","","",null,null],[7,"__kernel_stack_start","","",null,null],[7,"__kernel_stack_end","","",null,null],[7,"__trampoline_text_start","","",null,null],[17,"PAGE_ORDER","kernel::symbols","Page order",null,null],[17,"PAGE_SIZE","","Page size",null,null],[17,"MAXVA","","Maximum virtual address supported on Sv39",null,null],[17,"TRAMPOLINE_START","","Address to map kernel and user trampoline",null,null],[17,"TRAPFRAME_START","","Address to map trapframe",null,null],[17,"NCPUS","","Maximum supported CPU on machine",null,null],[17,"NMAXPROCS","","Maximum process on machine.",null,null],[17,"SCHEDULER_INTERVAL","","Scheduler timer interrupt interval",null,null],[0,"trap","kernel","Machine mode and supervisor mode traps",null,null],[5,"kerneltrap","kernel::trap","Process interrupt from supervisor mode",null,[[]]],[5,"usertrap","","Called by `uservec` in `trampoline.S`, return from user…",null,[[]]],[5,"trampoline_userret","","Jump to user space through trampoline after trapframe is…",null,[[["usize"]]]],[5,"usertrapret","","Jump to user space through trampoline",null,[[]]],[5,"hartinit","","Initialize supervisor-mode trap",null,[[]]],[0,"uart","kernel","UART driver module",null,null],[3,"Uart","kernel::uart","UART driver",null,null],[12,"base_address","","UART MMIO base address",22,null],[5,"uartintr","","Process UART interrupt. Should only be called when…",null,[[]]],[5,"UART","","Global function to get an instance of UART driver",null,[[],["mutex"]]],[5,"init","","",null,[[]]],[7,"__UART","","UART driver object",null,null],[17,"UART_BASE_ADDR","","UART base address on QEMU RISC-V",null,null],[11,"new","","",22,[[["usize"]],["self"]]],[11,"init","","Initialize UART driver",22,[[["self"]]]],[11,"put","","Put a character into UART",22,[[["self"],["u8"]]]],[11,"get","","Get a character from UART",22,[[["self"]],[["option",["u8"]],["u8"]]]],[0,"plic","kernel","RISC-V Platform-Level Interrupt Controller",null,null],[3,"Plic","kernel::plic","",null,null],[5,"PLIC_MENABLE","","",null,[[["usize"]],["usize"]]],[5,"PLIC_SENABLE","","",null,[[["usize"]],["usize"]]],[5,"PLIC_MPRIORITY","","",null,[[["usize"]],["usize"]]],[5,"PLIC_SPRIORITY","","",null,[[["usize"]],["usize"]]],[5,"PLIC_MCLAIM","","",null,[[["usize"]],["usize"]]],[5,"PLIC_SCLAIM","","",null,[[["usize"]],["usize"]]],[5,"PLIC","","Global function to get an instance of PLIC driver",null,[[],["plic"]]],[5,"init","","Initialize PLIC",null,[[]]],[5,"hartinit","","",null,[[]]],[7,"__PLIC","","PLIC driver object",null,null],[17,"PLIC_BASE","","",null,null],[17,"PLIC_PRIORITY","","",null,null],[17,"PLIC_PENDING","","",null,null],[17,"PLIC_MENABLE_BASE","","",null,null],[17,"PLIC_SENABLE_BASE","","",null,null],[17,"PLIC_MPRIORITY_BASE","","",null,null],[17,"PLIC_SPRIORITY_BASE","","",null,null],[17,"PLIC_MCLAIM_BASE","","",null,null],[17,"PLIC_SCLAIM_BASE","","",null,null],[17,"UART0_IRQ","","",null,null],[17,"VIRTIO0_IRQ","","",null,null],[11,"new","","",23,[[],["self"]]],[11,"next","","Get the next available interrupt. This is the \"claim\"…",23,[[["self"]],[["u32"],["option",["u32"]]]]],[11,"complete","","Complete a pending interrupt by id. The id should come…",23,[[["self"],["u32"]]]],[11,"init","","Initialize PLIC. Enable interrupt.",23,[[["self"],["u32"]]]],[11,"is_pending","","See if a given interrupt id is pending.",23,[[["self"],["u32"]],["bool"]]],[11,"enable","","Enable a given interrupt id",23,[[["self"],["u32"]]]],[11,"set_threshold","","Set the global threshold. The threshold can be a value…",23,[[["self"],["u8"]]]],[11,"set_priority","","Set a given interrupt priority to the given priority. The…",23,[[["self"],["u32"],["u8"]]]],[0,"clint","kernel","RISC-V Core Local Interrupter",null,null],[5,"CLINT_MTIMECMP","kernel::clint","",null,[[["usize"]],["usize"]]],[5,"timer_init","","Initialize machine-mode timer interrupt",null,[[]]],[5,"debug","","",null,[[]]],[7,"MSCRATCH0","","space for timer trap to save information.",null,null],[17,"CLINT_BASE","","",null,null],[17,"CLINT_MTIMECMP_BASE","","",null,null],[17,"CLINT_MTIME_BASE","","",null,null],[0,"syscall","kernel","Module for processing syscall",null,null],[5,"argraw","kernel::syscall","Get the `pos`th argument from syscall",null,[[["trapframe"],["usize"]],["usize"]]],[5,"arg_int","","Get the `pos`th argument as i32 from syscall",null,[[["trapframe"],["usize"]],["i32"]]],[5,"arg_uint","","Get the `pos`th argument as usize from syscall",null,[[["trapframe"],["usize"]],["usize"]]],[5,"arg_ptr","","Get the `pos`th argument as a pointer from syscall, return…",null,[[["table"],["usize"],["trapframe"]]]],[5,"arg_ptr_mut","","Get the `pos`th argument as a pointer from syscall, return…",null,[[["table"],["usize"],["trapframe"]]]],[5,"arg_fd","","Get file corresponding to a file descriptor",null,[[["process"],["usize"]],["arc"]]],[5,"sys_fork","","fork syscall entry",null,[[],["i32"]]],[5,"sys_exec","","exec syscall entry",null,[[],["i32"]]],[5,"sys_exit","","exit syscall entry",null,[[],["i32"]]],[5,"syscall","","Process all syscall",null,[[],["i32"]]],[0,"gen","","This module is automatically generated with…",null,null],[17,"SYS_FORK","kernel::syscall::gen","`0`: fork",null,null],[17,"SYS_EXIT","","`1`: exit",null,null],[17,"SYS_WAIT","","`2`: wait",null,null],[17,"SYS_PIPE","","`3`: pipe",null,null],[17,"SYS_READ","","`4`: read",null,null],[17,"SYS_WRITE","","`5`: write",null,null],[17,"SYS_CLOSE","","`6`: close",null,null],[17,"SYS_KILL","","`7`: kill",null,null],[17,"SYS_EXEC","","`8`: exec",null,null],[17,"SYS_OPEN","","`9`: open",null,null],[17,"SYS_MKNOD","","`10`: mknod",null,null],[17,"SYS_UNLINK","","`11`: unlink",null,null],[17,"SYS_FSTAT","","`12`: fstat",null,null],[17,"SYS_LINK","","`13`: link",null,null],[17,"SYS_MKDIR","","`14`: mkdir",null,null],[17,"SYS_CHDIR","","`15`: chdir",null,null],[17,"SYS_DUP","","`16`: dup",null,null],[17,"SYS_GETPID","","`17`: getpid",null,null],[17,"SYS_SBRK","","`18`: sbrk",null,null],[17,"SYS_SLEEP","","`19`: sleep",null,null],[17,"SYS_UPTIME","","`20`: uptime",null,null],[0,"file","kernel::syscall","File-related syscalls",null,null],[5,"sys_write","kernel::syscall::file","write syscall",null,[[],["i32"]]],[5,"sys_read","","read syscall",null,[[],["i32"]]],[5,"next_available_fd","","find a available file descriptor from files array in process",null,[[],[["option",["usize"]],["usize"]]]],[5,"sys_open","","open syscall, currently only support `/console` file.",null,[[],["i32"]]],[5,"sys_close","","close syscall",null,[[],["i32"]]],[5,"sys_dup","","dup syscall",null,[[],["i32"]]],[0,"start","kernel","RISC-V hart boot and initialize",null,null],[5,"kinit","kernel::start","Initialize kernel page table and drivers in machine mode,…",null,[[]]],[5,"kmain","","Initialize hart, start first process and begin scheduling",null,[[]]],[7,"MAY_BOOT","","Controls whether other harts may start boot procedure",null,null],[0,"jump","kernel","Never type and jump after RAII",null,null],[5,"do_nothing","kernel::jump","",null,[[]]],[5,"never_return","","A mock function with return type !",null,[[]]],[5,"return_to","","Return to a non-return function",null,[[]]],[0,"virtio","kernel","virt-io driver",null,null],[3,"VRingDesc","kernel::virtio","",null,null],[12,"addr","","",24,null],[12,"len","","",24,null],[12,"flags","","",24,null],[12,"next","","",24,null],[3,"VRingUsedElem","","",null,null],[12,"id","","",25,null],[12,"len","","",25,null],[3,"UsedArea","","",null,null],[12,"flags","","",26,null],[12,"id","","",26,null],[12,"elems","","",26,null],[3,"InflightOp","","",null,null],[12,"buf","","",27,null],[12,"status","","",27,null],[3,"VirtIOData","","",null,null],[12,"desc","","VIRTIO MMIO descriptor register",28,null],[12,"avail","","VIRTIO MMIO descriptor avail register (padding to page size)",28,null],[12,"used","","VIRTIO MMIO descriptor used register",28,null],[12,"free","","is descriptor free",28,null],[12,"used_idx","","used index of used array",28,null],[12,"info","","in-flight operations",28,null],[3,"VirtIO","","",null,null],[12,"0","","",29,null],[3,"Buf","","VIRTIO Buffer",null,null],[12,"valid","","",30,null],[12,"disk","","TODO: this can be removed",30,null],[12,"dev","","device ID",30,null],[12,"blockno","","block number",30,null],[12,"data","","buffer data",30,null],[3,"BlkOutHdr","","",null,null],[12,"blk_type","","",31,null],[12,"reserved","","",31,null],[12,"sector","","",31,null],[4,"VIRTIO_MMIO","","VIRTIO MMIO address offset",null,null],[13,"MAGIC_VALUE","","",32,null],[13,"VERSION","","",32,null],[13,"DEVICE_ID","","",32,null],[13,"VENDOR_ID","","",32,null],[13,"DEVICE_FEATURES","","",32,null],[13,"DRIVER_FEATURES","","",32,null],[13,"GUEST_PAGE_SIZE","","",32,null],[13,"QUEUE_SEL","","",32,null],[13,"QUEUE_NUM_MAX","","",32,null],[13,"QUEUE_NUM","","",32,null],[13,"QUEUE_ALIGN","","",32,null],[13,"QUEUE_PFN","","",32,null],[13,"QUEUE_READY","","",32,null],[13,"QUEUE_NOTIFY","","",32,null],[13,"INTERRUPT_STATUS","","",32,null],[13,"INTERRUPT_ACK","","",32,null],[13,"STATUS","","",32,null],[4,"VIRTIO_CONFIG_S","","",null,null],[13,"ACKNOWLDGE","","",33,null],[13,"DRIVER","","",33,null],[13,"DRIVER_OK","","",33,null],[13,"FEATURES_OK","","",33,null],[4,"VIRTIO_FEATURE","","",null,null],[13,"BLK_F_RO","","",34,null],[13,"BLK_F_SCSI","","",34,null],[13,"BLK_F_CONFIG_WCE","","",34,null],[13,"BLK_F_MQ","","",34,null],[13,"F_ANY_LAYOUT","","",34,null],[13,"RING_F_INDIRECT_DESC","","",34,null],[13,"RING_F_EVENT_IDX","","",34,null],[5,"VIRTIO","","Global function to get an instance of VirtIO driver",null,[[],["virtio"]]],[5,"init","","",null,[[]]],[5,"virtiointr","","VIRTIO interrupt",null,[[]]],[0,"tests","","",null,null],[5,"tests","kernel::virtio::tests","",null,[[]]],[5,"test_memory_layout","","Test virtio memory layout",null,[[]]],[5,"test_rw","","Test read and write",null,[[]]],[7,"__VIRTIO","kernel::virtio","VirtIO driver object",null,null],[17,"VIRTIO_MMIO_BASE","","VIRTIO base address on QEMU RISC-V",null,null],[17,"DESC_NUM","","",null,null],[17,"VRING_DESC_F_NEXT","","",null,null],[17,"VRING_DESC_F_WRITE","","",null,null],[17,"VIRTIO_BLK_T_IN","","",null,null],[17,"VIRTIO_BLK_T_OUT","","",null,null],[17,"AVAIL_SZ","","Size of avail array",null,null],[17,"BSIZE","","VIRTIO buffer size",null,null],[11,"val","","Get address of MMIO from enum",32,[[],["usize"]]],[11,"ptr","","Get pointer to MMIO register from enum",32,[[]]],[11,"val","","",33,[[],["u32"]]],[11,"bit","","",34,[[],["u32"]]],[11,"new","","",24,[[],["self"]]],[11,"new","","",25,[[],["self"]]],[11,"new","","",26,[[],["self"]]],[11,"new","","",30,[[],["self"]]],[11,"free_desc","","Free one descriptor",28,[[["self"],["usize"]]]],[11,"alloc_desc","","Allocate one descriptor",28,[[["self"]],[["option",["usize"]],["usize"]]]],[11,"alloc3_desc","","Allocate three descriptors, return array of indices",28,[[["self"]],["option"]]],[11,"free_chain","","Free descriptor chain",28,[[["self"],["usize"]]]],[11,"new","","",29,[[],["self"]]],[11,"init","","Initialize VIRTIO driver.",29,[[["self"]]]],[11,"rw","","Read-write operation",29,[[["box",["buf"]],["self"],["buf"],["bool"]],[["buf"],["box",["buf"]]]]],[11,"read","","Read from device and block number",29,[[["self"],["u32"]],[["buf"],["box",["buf"]]]]],[11,"write","","Write buffer to disk",29,[[["self"],["buf"],["box",["buf"]]]]],[0,"intr","kernel","Handle interrupts",null,null],[4,"Intr","kernel::intr","",null,null],[13,"Timer","","",35,null],[13,"Device","","",35,null],[5,"devintr","","Process device interrupts",null,[[],[["option",["intr"]],["intr"]]]],[0,"test","kernel","Test runner",null,null],[5,"run_tests","kernel::test","Run all tests in core os",null,[[]]],[6,"TestSuite","","",null,null],[0,"sleeplock","kernel","A lock which puts current process into sleep and allows…",null,null],[3,"SleepLockInfo","kernel::sleeplock","locked, pid",null,null],[12,"locked","","",36,null],[12,"pid","","",36,null],[3,"SleepLock","","",null,null],[12,"spin","","",37,null],[12,"name","","",37,null],[3,"SleepLockGuard","","",null,null],[12,"lock","","",38,null],[11,"new","","",36,[[["i32"],["bool"]],["self"]]],[11,"new","","",37,[[["str"]],["self"]]],[11,"acquire","","",37,[[["self"]],["sleeplockguard"]]],[11,"holding","","",37,[[["self"]],["bool"]]],[0,"file","kernel","File in core-os including file in filesystem, device, pipe…",null,null],[4,"File","kernel::file","File in core-os",null,null],[13,"Device","","",39,null],[13,"FsFile","","",39,null],[13,"Pipe","","",39,null],[0,"device","","Device trait for devices such as Console",null,null],[3,"Console","kernel::file::device","Console device",null,null],[8,"Device","","Device trait",null,null],[10,"read","","Read from file to content and returns number of characters…",40,[[["self"]],["i32"]]],[10,"write","","Write content to file and returns number of characters…",40,[[["self"]],["i32"]]],[0,"fsfile","kernel::file","File on file system",null,null],[3,"FsFile","kernel::file::fsfile","",null,null],[12,"offset","","",41,null],[12,"sz","","",41,null],[12,"rw_offset","","",41,null],[12,"readable","","",41,null],[12,"writable","","",41,null],[0,"tests","","",null,null],[5,"tests","kernel::file::fsfile::tests","",null,[[]]],[5,"test_open","","Test open",null,[[]]],[5,"test_read","","Test read",null,[[]]],[5,"test_read_elf","","Test read",null,[[]]],[17,"HEADER_SIZE","kernel::file::fsfile","",null,null],[17,"FILE_MAX","","",null,null],[11,"get_file_info","","",41,[[["str"],["virtio"]],["option"]]],[11,"open","","",41,[[["str"],["usize"]],["self"]]],[11,"read","","",41,[[["self"]],["i32"]]],[11,"write","","",41,[[["self"]],["i32"]]],[14,"print","kernel","Print information",null,null],[14,"println","","Print with a new line",null,null],[14,"panic_println","","Create a new UART object and print",null,null],[14,"info","","Prints an info, with newline.",null,null],[14,"warn","","Prints a warning, with newline.",null,null]],"p":[[3,"ELFHeader"],[3,"ProgramHeader"],[3,"Allocator"],[3,"Mutex"],[3,"MutexGuard"],[3,"WeakMutexGuard"],[3,"Table"],[3,"Page"],[3,"Entry"],[3,"VPN"],[3,"PPN"],[4,"EntryAttributes"],[4,"ProcInPool"],[3,"TrapFrame"],[4,"Register"],[3,"CPU"],[3,"IntrLock"],[3,"IntrLockGuard"],[3,"Process"],[4,"ProcessState"],[3,"Context"],[4,"ContextRegisters"],[3,"Uart"],[3,"Plic"],[3,"VRingDesc"],[3,"VRingUsedElem"],[3,"UsedArea"],[3,"InflightOp"],[3,"VirtIOData"],[3,"VirtIO"],[3,"Buf"],[3,"BlkOutHdr"],[4,"VIRTIO_MMIO"],[4,"VIRTIO_CONFIG_S"],[4,"VIRTIO_FEATURE"],[4,"Intr"],[3,"SleepLockInfo"],[3,"SleepLock"],[3,"SleepLockGuard"],[4,"File"],[8,"Device"],[3,"FsFile"]]};
searchIndex["user"] = {"doc":"User-space library","i":[[5,"panic","user","",null,[[["panicinfo"]]]],[5,"abort","","",null,[[]]],[0,"print","","",null,null],[3,"StdIO","user::print","",null,null],[11,"new","","",0,[[],["self"]]],[0,"syscall","user","All syscalls of core-os",null,null],[5,"exit","user::syscall","Exit current process with exit code `code`.",null,[[["i32"]]]],[5,"fork","","Fork current process. ",null,[[],["i32"]]],[5,"exec","","Replace current process image with the new one in the…",null,[[["str"]]]],[5,"write","","Write `content` to file descriptor `fd`.",null,[[["i32"]],["i32"]]],[5,"read","","Read `content` from file descriptor `fd`.",null,[[["i32"]],["i32"]]],[5,"open","","Open file of `path` with `mode`.",null,[[["str"],["i32"]],["i32"]]],[5,"close","","Close a file with file descriptor `fd`.",null,[[["i32"]],["i32"]]],[5,"dup","","Duplicate file descriptor `fd`.",null,[[["i32"]],["i32"]]],[5,"wait","","",null,[[["i32"]],["i32"]]],[17,"EXEC_MAX_ARGS","","",null,null],[0,"constant","user","Constants in user-space",null,null],[17,"STDIN","user::constant","",null,null],[17,"STDOUT","","",null,null],[17,"STDERR","","",null,null],[0,"syscall_internal","user","Internal representation of syscall",null,null],[5,"__write","user::syscall_internal","",null,null],[5,"__read","","",null,null],[5,"__exit","","",null,null],[5,"__fork","","",null,null],[5,"__exec","","",null,null],[5,"__open","","",null,null],[5,"__close","","",null,null],[5,"__dup","","",null,null],[5,"__wait","","",null,null],[14,"print","user","",null,null],[14,"println","","",null,null],[14,"format","","",null,null]],"p":[[3,"StdIO"]]};
addSearchOptions(searchIndex);initSearch(searchIndex);